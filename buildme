#!/usr/bin/env python3
# Use README.md as a literate build tool.
#
# Parse structured text into shell invocations with supporting prerequisite
# checks (programs on PATH, generally), repo clones, and checksum-verified web
# downloads. When a code block has a documented effect of creating specific
# files and directories, provide build caching and `clean` workflows.
#
# Indicate build instructions with markdown and a few English words.
#
# Text parsing is approximately faithful to the markdown spec, but makes
# pragmatic concessions when the spec complicates what could be easily fixed
# by a simple README edit (resulting in text that is better organized).
#
# When editing a .md file, use `--outline` and `--export` to confirm document
# structure, because the literate approach ignores unknown text by default.
#
# Use only the Python standard library. Require Python 3.6+.

# Flow of command-line application:
#
#     Main
#     Project(*filename)
#       Document(filename)  # Markdown parsed here.
#     Runner(project).run   # Build runs here.
#       Output

__version__ = "0.0-dev"

PROG = "buildme"

MAJOR = int(__version__.split(".")[0])
V = "v" + str(MAJOR)


import sys

if sys.version_info < (3, 6):
    sys.stderr.write(PROG + " error: Python 3.6+ required\n")
    sys.exit(128)

import argparse
import collections
import contextlib
import doctest
import functools
import inspect
import itertools
import json
import os
import platform
import re
import traceback


### Style Note
#
# This module uses singular names. Everything is a vector.
#
#   project                        Project
#     .document = [d]              Document
#       .section = [sec]           Section
#         .component = [cmp]       Component
#           .blk = blk             Block
#
#   block = [blk]                  Block
#     .cmp = cmp                   Component
#     .line = [s]                  str
#
###


## Class Utility


class classproperty(property):
    "Use a class method as a property (combine @classmethod with @property)."

    def __get__(decorator, _, cls):
        return decorator.fget(cls)


## Text Parsing


def parse(text):
    "Parse markdown text (file or iterable) into list of Block objects."
    return list(link(Block.classify(scan(text))))


# Markdown scan states.
FENCED = object()
INDENTED = object()
COMMENT = object()
LIST = object()


def scan(text):
    """Scan markdown text for its block structure.

    Return `(line number, [line])` pairs, where `[line]` is the list of lines
    contained by a given block and `line_number` is the position of the first
    line.

    Spec:
    https://spec.commonmark.org/0.30/
    """
    state, fence = None, "```"

    i, acc = 0, []
    count = 0

    for line in text:
        line = line.rstrip()  # Trailing whitespace is never significant.
        count += 1

        # Continuing a block takes precedence, in order of precedence.
        if state is FENCED and not re.match(r"\s{0,3}" + fence, line):
            cont = True
        elif state is INDENTED and (not line or line.startswith("    ")):
            cont = True
        elif state is COMMENT and "-->" not in line:
            cont = True
        elif state is LIST and line:
            cont = True
        else:
            cont = False

        if cont:
            acc.append(line)
            continue

        # One block ends, another begins.
        if state is FENCED and re.match(r"\s{0,3}" + fence, line):
            end = True
        elif state is INDENTED and (line and not line.startswith("    ")):
            end = True
        elif state is COMMENT and "-->" in line:
            end = True
        elif state is LIST and not line:
            end = True
        elif state is None and acc and not line:
            end = True
        else:
            end = False

        # Only a new, unindented block confirms the end of an indented block.
        if end and state is INDENTED:
            if not acc[-1]:
                acc.pop(-1)  # Remove blank line between blocks.
            yield i, acc
            i, acc = 0, []
            state = None
            end = False

        # Include the final non-blank line with the block.
        if end and line:
            acc.append(line)

        # Yield the ending block.
        if end:
            yield i, acc
            i, acc = 0, []
            state = None
            continue

        # Blank lines outside of blocks are insignificant.
        if not line:
            continue

        # Determine whether the new block has precedence in continuation.
        assert state is None

        if re.match(r" {0,3}(```|~~~)\S*", line):
            state = FENCED
            fence = re.match(r" {0,3}(```|~~~)\S*", line).group(1)
        elif line.startswith("    "):
            state = INDENTED
        elif "<!--" in line and "-->" not in line:
            state = COMMENT
        elif re.match(r"\s*[\*-+] ", line):
            state = LIST

        # Collect lines into the new block.
        if not acc:
            i, acc = count, [line]
        else:
            acc.append(line)

    # Yield the final block.
    if acc:
        yield i, acc


def link(xs):
    "Set `next` and `prev` attributes to neighbors on each item in iterable."
    prev = None
    for x in xs:
        if prev:
            prev.next = x
        prev, x.prev = x, prev
        x.next = None
        yield x


class Block:
    "A markdown block."

    def __init__(self, i, line):
        self.i = i
        self.line = line
        self.text = "\n".join(line)

    @classproperty
    def default(cls):
        """Use this class when parsing does not return an instance.

        The default block class will appear anywhere a block type is not
        supported, e.g. HTML blocks.
        """
        return Paragraph

    @classmethod
    def classify(cls, scanned):
        """Classify markdown blocks from `scan` into types (Python classes).

        Accept the `(line number, [line])` output of `scan`. Call the `parse`
        class method of each subclass, in arbitrary order, and when a subclass
        constructs an instance, move on to the next input block. That is,
        classifying an input block is first come, first serve.

        Handle markdown blocks only, not inline structure.
        """
        parser = [c.parse for c in subclass(cls) if c is not cls.default]
        for i, line in scanned:
            for parse in parser:
                parsed = parse(i, line)
                if parsed:
                    yield parsed
                    break
            else:
                yield cls.default(i, line)

    @classmethod
    def parse(cls, i, line):
        "Given an input block, return an instance (exactly one) or None."
        raise NotImplementedError("Block subclass must provide `parse`.")

    def __repr__(self):
        arg = ", ".join(
            f"{p}={getattr(self, p)!r}"
            for p in inspect.signature(self.__init__).parameters
        )
        return f"{self.__class__.__name__}({arg})"


class Paragraph(Block):
    "Text."


class Break(Block):
    """Thematic break, i.e. horizontal rule.

    Markdown may support inline thematic breaks, but this class only represents
    blocks. Further, this class only matches thematic breaks on their own,
    i.e. does not interfere with setext-style headings.
    """

    @classmethod
    def parse(cls, i, line):
        if len(line) == 1 and re.match(r"^(---|___|\*\*\*)$", line[0]):
            return cls(i, line)


class Heading(Block):
    "Title or section subtitle."

    def __init__(self, i, line):
        super().__init__(i, line)

        if self.is_setext(line):
            self.style = "setext"
            self.content = line[0]
            self.level = 1 if "=" in line[1] else 2
        else:
            self.style = "atx"
            assert len(line) == 1
            match = re.match(r"(#+)\s+(.*)", line[0])
            self.content = match.group(2)
            self.level = len(match.group(1))

    @classmethod
    def is_atx(cls, line):
        return len(line) == 1 and bool(re.match(r"^#{1,6}\s+", line[0]))

    @classmethod
    def is_setext(cls, line):
        if len(line) != 2 or len(line[0]) != len(line[1]):
            return False
        return bool(re.match(r"^(=+|-+)$", line[1]))

    @classmethod
    def parse(cls, i, line):
        if cls.is_setext(line) or cls.is_atx(line):
            return cls(i, line)


class Code(Block):
    """Code, either indented or fenced.

    Markdown supports indented code fences with up to three spaces of
    indentation. Markdown also supports end-of-file instead of a closing fence,
    motivated because backtracking is less efficient, but parsing here does not
    require backtracking so a closing fence is required.
    """

    fence_re = r"( {0,3})(```|~~~)(\S*)$"  # Opening fence.

    def __init__(self, i, line):
        super().__init__(i, line)
        self.fence = None
        self.indent = 0
        self.language = None

        if self.is_fenced(line):
            # Fenced code blocks support indentation and either ` or ~ fences.
            self.style = "fenced"
            match = re.match(self.fence_re, line[0])
            self.fence = match.group(2)
            if match.group(1):
                # Opening fence has indentation.
                self.indent = len(match.group(1))
            if match.group(3):
                # Opening fence has info string, a language by convention.
                self.language = match.group(3)
        else:
            self.style = "indented"
            self.indent = 4

        # Parse code content.
        code = line[1:-1] if self.fence else line  # Exclude fence syntax.
        if self.indent:
            # Dedent, but only remove spaces.
            dent = "^ " + "{0," + str(self.indent) + "}"
            code = [re.sub(dent, "", s) for s in code]
        self.content = "\n".join(code)

    @classmethod
    def is_fenced(cls, line):
        if len(line) < 2:
            return False

        match = re.match(cls.fence_re, line[0])
        if match:
            fence = match.group(2)  # ``` or ~~~
            return bool(re.match(" {0,3}" + fence + r"\s*$", line[-1]))
        return False

    @classmethod
    def is_indented(cls, line):
        return all([s.startswith("    ") for s in line if s])

    @classmethod
    def parse(cls, i, line):
        if cls.is_fenced(line) or cls.is_indented(line):
            return cls(i, line)


class Iterable:
    "Mixin to iterate through sub-items."

    sub = "item"  # Name of sub-item attribute.

    def __iter__(self):
        "Implement iterator protocol."

        class Iterator:
            def __init__(self, item):
                self.item = item
                self.index = -1
                self.length = len(self.item)

            def __next__(self):
                self.index += 1
                if self.index >= self.length:
                    raise StopIteration
                return self.item[self.index]

        return Iterator(getattr(self, self.sub))


class ListItem(Block):
    "An item in a list, either ordered or unordered."

    marker_re = r"\s*([\-\+\*]\s|[0-9]{1,9}[\.\)]\s)"

    def __init__(self, list, i, line, level=1):
        super().__init__(i, line)
        self.list = list
        self.level = level

        # Track ordered/unordered independently of List.
        if re.match(r"\s*[0-9]", line[0]):
            self.style = "ordered"
        else:
            self.style = "unordered"

        # Parse the bullet in use, for completeness: `-`, `+`, or `*`.
        match = re.match(r"\s*([\-\+\*])", line[0])
        if match:
            self.bullet = match.group(1)  # Unordered.
        else:
            self.bullet = None

        # Parse the ordered list delimiter, for completeness: `.` or `)`.
        match = re.match(r"\s*[0-9]+([\.\)])", line[0])
        if match:
            self.delimiter = match.group(1)  # Ordered.
        else:
            self.delimiter = None

        # Parse list item content.
        self.content = re.sub(self.marker_re, "", self.text)

    @property
    def container(self):
        "Alias to `self.list` for a generic duck-typed data model."
        return self.list

    @classmethod
    def parse(cls, i, line):
        "Create instances only through `List` construction."
        return


class List(Block, Iterable):
    """A list, either ordered or unordered.

    ListItem instances have `level` attribute counting up from `1`, flattened
    into a single List instance (instead of nested List instances).

    Treat ordered unordered lists in the same way. Ignore when the bullet or
    ordered list delimiter changes, instead of starting a new list. Assume all
    lists are "tight" without blank lines separating list items.  Assume
    indentation is with spaces only (no tabs).

    In effect, given the parsing assumptions above, a List may contain a mix of
    ordered and unordered list items, if the source text is disorganized as
    such. Expect blank lines instead of "fixing" this problem when parsing.

    Any calling code can adjust for mixed bullets/delimiters by inspecting the
    attributes of the enclosed ListItem instances.
    """

    list_item_cls = ListItem

    def __init__(self, i, line):
        super().__init__(i, line)

        # While parsing can result in a mixed list, take note of first item.
        if re.match(r"\s*[0-9]", line[0]):
            self.style = "ordered"
        else:
            self.style = "unordered"

        # Group continuing lines together.
        group, acc = [], [line[0]]
        for s in line[1:]:
            if re.match(self.list_item_cls.marker_re, s):
                group, acc = group + [acc], [s]
            else:
                acc.append(s)
        group, acc = group + [acc], []

        # Determine set of indentations.
        dent = set(re.match(r"(\s*)", acc[0]).group(1) for acc in group)
        order = sorted(dent, key=lambda s: len(s))
        level = {s: rank for rank, s in enumerate(order, start=1)}

        # Create ListItem per group, reconstruct `i`, determine indent `level`.
        item_i, item = i, []
        for acc in group:
            ws = re.match(r"(\s*)", acc[0]).group(1)
            item.append(self.list_item_cls(self, item_i, acc, level=level[ws]))
            item_i += len(acc)  # Track line number of each list item.
        self.item = item

    @classmethod
    def parse(cls, i, line):
        if re.match(cls.list_item_cls.marker_re, line[0]):
            return cls(i, line)


class Comment(Block):
    """A single-line or multiline comment, marked by HTML comment syntax.

    Multiple single-line comments on a line are supported, but a single-line
    comment and the start of a multiline comment on the same line is not
    supported (because its block structure is ambiguous).

    Multiple single-line comments are, in essence, multiple blocks on a single
    line. Using HTML in markdown is idiosyncratic. In effect, multiple
    single-line comments on a line are a multi-line comment, with each
    single-line comment appending a line to the comment's content.
    """

    def __init__(self, i, line):
        super().__init__(i, line)

        # Parse comment within HTML, support multiple comments on a line.
        comment = []
        text = "\n".join(line).strip()

        for _ in range(text.count("-->")):  # Upper bound, avoid infinite loop.
            if not re.search("<!--|-->", text):
                break

            # Extract `s` from "<!--{s}-->".
            _, wip = re.split("<!--", text, maxsplit=1)
            s, text = re.split("-->", wip, maxsplit=1)

            # Strip single-line comment.
            if "\n" not in s:
                s = s.strip()

            comment.append(s)

        self.content = "\n".join(comment)

    @classmethod
    def parse(cls, i, line):
        if "<!--" in line[0]:
            return cls(i, line)


class Blockquote(Block):
    "Block quote, i.e. text email style quoting with `> ` notation."

    def __init__(self, i, line):
        super().__init__(i, line)

        # Determine quote indentation based on first line.
        # For content, strip quote indentation and empty quoted lines.
        quote = re.match(r"(\s*>\s*)\S", line[0]).group(1)
        quoted = [re.sub(rf"^({quote})|(\s*>$)", "", s) for s in line]
        self.content = "\n".join(quoted)

    @classmethod
    def parse(cls, i, line):
        if line[0].lstrip().startswith(">"):
            return cls(i, line)


## Data Model


class Project:
    """A collection of README/markdown files to run as a build system.

    Class composition, each has zero or many instances of the objects below it:

        Project
          Document
            Section
              Component (subclasses)

    A Project is a collection of files specified via command line (argv).
    A Document maps to a text file.
    A Section is marked by a heading in the text.
    Build Components within a Section are parsed from the section text.
    """

    def __init__(self, *filename):
        self.filename = filename
        self.document = [Document(f) for f in filename]

    def export(self):
        "Convert object to dictionary."
        return {"buildme": V, "document": [d.export() for d in self.document]}

    def outline(self):
        "Provide human-readable outline of Project features."
        return "\n".join(d.outline() for d in self.document)

    def __repr__(self):
        arg = ", ".join(repr(f) for f in self.filename)
        return f"{self.__class__.__name__}({arg})"


class Document:
    "A structured text file to parse as build instructions."

    def __init__(self, filename):
        self.filename = filename

        self.name = None  # Default.
        self.level = 1  # Default.

        self.__class__.Parser.parse(self)

    class Parser:
        "A collection of functions only sensible to Document internals."

        V_RE = rf"{PROG}\s+v([0-9]+)"  # Directive for minimum major version.

        @classmethod
        def block_component_cls(parser, blk):
            "Return relevant Component classes for a given Block class."
            if not hasattr(parser, "block_component"):  # Cached.
                # {Block: [Component]}
                parser.block_component = one_to_many(
                    subclass(parser.section_cls.component_cls),
                    key=lambda cls: cls.Block,
                )

            component_cls = []
            for blk_cls in type(blk).mro():  # Include base classes.
                for cls in parser.block_component.get(blk_cls, []):
                    component_cls.append(cls)
            return component_cls

        @classmethod
        def group(parser, block):
            "Group block instances by each Heading; each group is a Section."
            group, acc = [], []
            for blk in block:
                if isinstance(blk, parser.heading_cls):
                    if acc:
                        group.append(acc)
                    acc = []
                acc.append(blk)
            if acc:
                group.append(acc)
            return group

        @classproperty
        def heading_cls(parser):
            "Forward declaration for handle to Heading class."
            return Heading

        @classmethod
        def nonempty(parser, section):
            "Filter Section collection to instances that are not empty."
            return list(filter(lambda s: not s.empty, section))

        @classmethod
        def parse(parser, self):
            "Parse text into Document with zero or more Section instances."

            heading = None

            with context(filename=self.filename):
                with open_file_or_stdin(self.filename) as file:
                    # Parse file into Block instances, group by Heading.
                    group = parser.group(parse(file))

                    # Before processing, scan for minimum required version.
                    parser.validate_version(group)

                    # Find top-level heading, if it exists, for Document title.
                    heading = parser.title(group)
                    if heading:
                        assert group[0].pop(0) is heading  # Remove.
                        if not group[0]:
                            group.pop(0)  # No content, remove group.

                        self.name = getattr(heading, "content", self.name)
                        self.level = getattr(heading, "level", self.level)

                    # Build instances of Section and their Component parts.
                    self.section = parser.parse_section(self, group)

        @classmethod
        def parse_section(parser, self, group):
            "Build instances of Section and Component from block objects."

            section = []

            for block in group:
                heading, component = None, []

                if isinstance(block[0], Heading):
                    heading = block[0]

                for blk in block:
                    for blk in list(blk) if isiter(blk) else [blk]:
                        with context(line_number=blk.i):
                            for cls in parser.block_component_cls(blk):
                                cmp = cls.from_block(blk)
                                if cmp:
                                    blk.cmp = cmp
                                    if isiter(cmp):
                                        component += list(cmp)
                                    else:
                                        component.append(cmp)
                                    break
                            else:
                                blk.cmp = None

                section.append(parser.section_cls(self, component, heading))

            return parser.nonempty(section)

        @classproperty
        def section_cls(parser):
            "Forward declaration for handle to Section class."
            return Section

        @classmethod
        def title(parser, group):
            """Given block groups, determine top-level Heading of Document.

            If the first section has a heading that is greater than all other
            section groups in the text, then it is the Document title.
            """
            if not group:
                return None

            if not isinstance(group[0][0], parser.heading_cls):
                return None

            first = group[0][0].level
            same = list(filter(lambda g: g[0].level <= first, group[1:]))
            if not same:
                return group[0][0]

        @classmethod
        def validate_version(parser, group, MAJOR=MAJOR):
            """Scan for a major version directive, fail immediately if not met.

            Importantly, this process scans markdown blocks before they are
            interpreted by `buildme`.
            """
            for block in group:
                for blk in block:
                    if not isinstance(blk, Comment):
                        continue
                    with context(line_number=blk.i):
                        for s in blk.line:
                            match = re.search(parser.V_RE, s)
                            if match:
                                major = int(match.group(1))
                                if major <= MAJOR:
                                    continue
                                raise DocumentError(
                                    f"text requires v{major}"
                                    + f", but this is: {VERSION}"
                                )

        def __repr__(self):
            return f"{self.__class__.__name__}()"

    def export(self):
        "Convert object to dictionary."
        return {
            "filename": self.filename,
            "level": self.level,
            "name": self.name,
            "section": [sec.export() for sec in self.section],
        }

    def outline(self):
        "Provide human-readable outline of Document features."
        return "\n".join(
            [f"{' ' * (self.level - 1)}{self.title}"]
            + [sec.outline() for sec in self.section]
        )

    @property
    def title(self):
        "The top heading in the text, if it exists; else the filename."
        return self.name or self.filename

    def __repr__(self):
        return f"{self.__class__.__name__}({self.filename!r})"


class Section:
    """A section of Document text defining steps of the build process.

    Instantiated with a list of Component instances parsed by `Document.parse`.
    """

    def __init__(self, document, component, heading=None):
        self.document = document
        self.component = component

        # No heading means Section starts at document start.
        self.name = getattr(heading, "content", None)
        self.level = getattr(heading, "level", document.level)
        self.i = getattr(heading, "i", 1)

        self.empty = not bool(component)
        self.index()

    @classproperty
    def component_cls(cls):
        "Forward declaration for handle to Component base class."
        return Component

    def export(self):
        "Convert object to dictionary."
        return {
            "component": [cmp.export() for cmp in self.component],
            "level": self.level,
            "line": self.i,
            "name": self.name,
        }

    def index(self):
        "Index component collection by Component category."
        for category in self.component_cls.category_set:
            setattr(self, category, [])
        for cmp in self.component:
            getattr(self, cmp.category).append(cmp)

    def outline(self):
        "Provide human-readable outline of Section features."
        indent = " " * (self.level - 1)
        line = []

        if self.name:
            line.append(f"{indent}{self.name}")

        by_category = lambda x: x.category
        for category, xs in itertools.groupby(self.component, key=by_category):
            xs = list(xs)
            if not xs[0].outline_info():
                if len(xs) == 1:
                    line += [f"{indent} {category}"]
                else:
                    line += [f"{indent} {category} x{len(xs)}"]
            elif len(xs) == 1:
                line += [f"{indent} {xs[0].outline()}"]
            else:
                line += [f"{indent} {category}:"]
                for x in xs:
                    line += [f"{indent}  {x.outline_info()}"]

        return "\n".join(line)

    def __repr__(self):
        arg = f"name={self.name!r}, level={self.level!r}"
        return f"{self.__class__.__name__}({arg})"


# Special `re` value indicating that all content is to be captured.
ALL = object()


class Component:
    "A feature within a Section describing a component of the build process."

    Block = None  # Block class indicating which markdown block has component.

    category = None  # Simplified label for type.
    conditional_lead_in = None  # Paragraph lead-in for conditional execution.
    export_exclude = None  # Attribute names to exclude from `export`.
    export_include = None  # Additional attribute names to include in `export`.
    lead_in = None  # Paragraph lead-in indicating text is build instruction.
    re = None  # Regular expression for content within markdown block.
    subcategory = None  # Additional label within category, optional.

    @classproperty
    def category_set(cls):
        "Set of every `category` declared by a Component subclass."
        return set(c.category for c in subclass(cls) if c.category)

    def export(self):
        "Convert object to dictionary."
        include = self.export_include or []
        exclude = self.export_exclude or []
        export = {"category": self.category, "line": self.i}
        if getattr(self, "subcategory", None):
            export["subcategory"] = self.subcategory
        for key in list(inspect.signature(self.__init__).parameters) + include:
            if key in exclude:
                continue
            value = getattr(self, key, None)
            if callable(getattr(value, "export", None)):
                value = value.export()
            export[key] = value
        return export

    @classmethod
    def from_block(cls, blk):
        """Create Component instance from Block instance, else return None.

        This class method is called on each Block instance at the end of text
        processing. The factory method is common to all Component subclasses,
        whereby class attributes declare how to identify which markdown content
        defines build instructions.
        """
        if not cls.re or not cls.lead_in:
            return None  # Class does not create instances, i.e. is base class.

        if not isinstance(blk, cls.Block):
            return None  # Given block is not a Block class for this component.

        if not blk.content:
            return None  # Markdown block does not contain content.

        if getattr(blk, "container", None):
            # Block is contained by another, need container for lead-in check.
            context = blk.container
        else:
            context = blk

        if cls.paragraph_lead_in(cls.conditional_lead_in, context):
            conditional = True
        elif cls.paragraph_lead_in(cls.lead_in, context):
            conditional = False
        else:
            return None  # Lead-in required, no lead-in language found.

        return cls.from_content(blk, conditional=conditional)

    @classmethod
    def from_content(cls, blk, conditional=False):
        """Create Component instance from Block content, else return None.

        This class method assumes all criteria for a given block (and its
        context) are met for the Component, including lead-in language and
        block type. That is, this class method primarily exists to be called at
        the end of the `from_block` class method.
        """
        if isinstance(cls.re, str):
            pattern = [cls.re]
        elif cls.re is ALL:
            pattern = []
        else:
            pattern = cls.re

        a, kw = (), {}  # Argument tuple, keyword dictionary for new instance.

        if getattr(cls, "conditional_lead_in", None):
            kw["conditional"] = conditional

        for candidate in pattern:
            match = re.match(candidate, blk.content, flags=re.MULTILINE)
            if match:
                a = match.groups()
                if hasattr(cls, "process_re_groups"):
                    a = cls.process_re_groups(a)
                break

        if cls.re is ALL:
            a = (blk.content,)

        if not a:
            return None

        cmp = cls(*a, **kw)
        cmp.blk = blk
        cmp.i = blk.i
        return cmp

    @classmethod
    def paragraph_lead_in(cls, lead_in, blk):
        "Determine whether preceding paragraph matches lead-in pattern."
        if not lead_in:
            return False

        if not blk.prev or not isinstance(blk.prev, Paragraph):
            return False

        if not isinstance(lead_in, str):
            lead_in = "|".join(lead_in)

        lead_in_re = r"({}).*:$".format(lead_in.lower())

        return bool(re.match(lead_in_re, blk.prev.line[-1].lower()))

    def outline(self):
        "Provide human-readable outline information of Component feature."
        line = self.outline_info()
        if line:
            return f"{self.category}: {line}"
        return self.category

    def outline_info(self):
        "Provide outline information using first positional argument."
        for key in inspect.signature(self.__init__).parameters:
            value = getattr(self, key, None)
            if type(value) in (list, tuple):
                value = ", ".join(value)
            return str(value) if value else None

    def __repr__(self):
        arg = ", ".join(
            f"{p}={getattr(self, p)!r}"
            for p in inspect.signature(self.__init__).parameters
        )
        return f"{self.__class__.__name__}({arg})"


class Prerequisite(Component):
    "A requirement that must be met before continuing the build."

    Block = ListItem

    category = "prerequisite"
    conditional_lead_in = r"if\s+.*\s*(is|are)\s+(missing|needed|not)"
    export_exclude = ["value"]  # Prefer a field keyed by subcategory.
    lead_in = "require[sd]?|make sure"

    def __init__(self, value, conditional=False):
        self.value = value
        self.conditional = conditional
        setattr(self, self.subcategory, value)

    @classproperty
    def export_include(cls):
        "Export a field keyed by derived subcategory."
        return [cls.subcategory]

    @classproperty
    def subcategory(cls):
        "Derive subcategory attribute from class name."
        return cls.__name__.replace("Prerequisite", "").lower()


class ProgramPrerequisite(Prerequisite):
    "A program that must be on the $PATH before continuing the build."

    re = r"`([^\s/\\]*)`"


class FilePrerequisite(Prerequisite):
    """A file that must exist on the filesystem before continuing the build.

    In order to disambiguate from `ExpressionPrerequisite`, a file cannot
    contain spaces.
    """

    re = [
        r"`(\S*/[\S/]*)`",  # Unix path separator: /.
        r"`(\S*\\[\S\\]*)`",  # Windows path separator: \.
    ]


class ExpressionPrerequisite(Prerequisite):
    "A shell expression to run successfully before continuing the build."

    re = r"`(.* .*)`"


class Download(Component):
    "A download step as part of the build."

    Block = ListItem

    category = "download"


class TagSpec:
    "Mixin to extract tags from a regular expression group."

    @classmethod
    def process_re_groups(cls, groups):
        "Parse list of tags from comma-delimited text."
        i = getattr(cls, "tag_group", 1) - 1  # re.match is 1-indexed.
        if i >= len(groups):
            return groups
        head, tag_spec, tail = groups[:i], groups[i], groups[i + 1 :]

        if tag_spec:
            tag = tag_spec.replace(",", "").replace(" and ", " ").split(" ")
        else:
            tag = []

        return head + (tag,) + tail


class RepoClone(Download, TagSpec):
    "A repository to clone as part of the build."

    lead_in = "clone"
    re = [
        r"(\S+)\s+as\s+(.*)\s+including\s+tags?\s+(.*)",
        r"(\S+)\s+()including\s+tags?\s+(.*)",
        r"(\S+)\s+a[ts]\s+(.*)\s+tags?\s+(.*)",
        r"(\S+)\s+()tags?\s+(.*)",
        r"(\S+)",
    ]
    subcategory = "clone"
    tag_group = 3

    def __init__(self, repo, directory=None, tag=None):
        self.repo = repo
        self.directory = directory or None
        self.tag = tag or None

    def outline_info(self):
        "Provide info on clone configuration."
        line = self.repo
        if self.directory:
            line += f" as {self.directory}"
        if self.tag:
            line += f" ({', '.join(self.tag)})"
        return line


class Checksum:
    "An algorithm and checksum for use in download verification."

    def __init__(self, algorithm, checksum):
        self.algorithm = algorithm
        self.checksum = checksum

    def export(self):
        "Convert object to dictionary."
        return vars(self)

    def __repr__(self):
        arg = f"{self.algorithm!r}, {self.checksum!r}"
        return f"{self.__class__.__name__}({arg})"


class DownloadAttributes:
    "Mixin to extract multiple attributes from a regular expression group."

    algorithms = ("md5", "sha1", "sha224", "sha256", "sha384", "sha512")
    delimiter = ";"
    subdelimiter = ","

    @classmethod
    def parse_arch(cls, text):
        "Parse one or more delimited values following 'arch:'."
        match = re.match(r"arch:\s*(.*)", text.lower())
        if match:
            group = match.group(1)
            if cls.subdelimiter in group:
                return [arch.strip() for arch in group.split(cls.subdelimiter)]
            return [group.strip()]

    @classmethod
    def parse_checksum(cls, text):
        "Parse Checksum object from text notation."
        pattern = r"({}):\s*(\S*)".format("|".join(cls.algorithms))
        match = re.match(pattern, text.lower())
        if match:
            return Checksum(algorithm=match.group(1), checksum=match.group(2))

    @classmethod
    def process_re_groups(cls, groups):
        i = getattr(cls, "attributes_group", 1) - 1  # re.match is 1-indexed.
        if i >= len(groups):
            return groups

        head, text, tail = groups[:i], groups[i], groups[i + 1 :]

        attributes = {}

        for part in text.split(cls.delimiter):
            part = part.strip()
            arch = cls.parse_arch(part)
            checksum = cls.parse_checksum(part)
            if arch:
                attributes["arch"] = arch
            elif checksum:
                attributes["checksum"] = checksum
            else:
                raise DocumentError("unknown download attribute: " + part)

        return head + (attributes,) + tail


class WebDownload(Download, DownloadAttributes):
    "A file to download from the web as part of the build."

    action = "download"
    attributes_group = 3
    export_exclude = ["attributes"]
    export_include = ["arch", "checksum"]
    lead_in = "download"
    re = [
        r"(\S+)\s+as\s+(\S+)\s+\((.*)\)",
        r"(\S+)\s*()\((.*)\)",
        r"(\S+)",
    ]
    subcategory = "web"

    def __init__(self, url, filename=None, attributes={}):
        self.url = url
        self.filename = filename or None
        self.attributes = attributes

        self.arch = None
        self.checksum = None
        for k, v in attributes.items():
            setattr(self, k, v)

    def outline_info(self):
        "Provide info on download configuration."
        line = self.url
        if self.filename:
            line += f" as {self.filename}"
        if self.checksum:
            line += f" ({self.checksum.algorithm})"
        return line


class Script(Component):
    "A script to run as part of the build."

    Block = Code

    category = "script"
    lead_in = [
        "create|prep|prepare|setup",
        "do|run",
        "log",
        "test",
        "unarchive|unpack",
    ]
    re = ALL

    def __init__(self, code, language=None):
        self.code = code
        self.language = language

    def outline_info(self):
        "Skip code listing in outline."
        return None


class DirectiveSet(Component, Iterable):
    """One or more directives indicated by a comment in the text.

    A Comment block can have multiple directives, separated by semi-colons or
    new lines. The role of this class is to be a one-to-one mapping between a
    Component and a Comment, then parse the expressions in the comment content
    for each Directive. This class is a container.
    """

    Block = Comment

    delimiter_re = "[;\n]"
    sub = "directive"

    def __init__(self, directive):
        self.directive = directive

    @classproperty
    def directive_cls(cls):
        "Forward declaration for handle to Directive class."
        return Directive

    @classmethod
    def from_block(cls, blk):
        "Override `Component.from_block` in order to parse within Comment."
        if not isinstance(blk, cls.Block):
            return None  # Not a Comment.

        if not blk.content:
            return None  # Comment has no content.

        directive_cls = [c for c in subclass(cls.directive_cls) if c.re]

        # Parse vector of delimited, non-empty comment segments.
        comment = re.split(cls.delimiter_re, blk.content)
        comment = [s.strip() for s in comment if s.strip()]

        directive = []
        unmatched = []

        for part in comment:
            for c in directive_cls:
                cmp = cls.from_comment(c, part)
                if cmp:
                    cmp.blk = blk
                    cmp.i = blk.i
                    directive.append(cmp)
                    break
            else:
                unmatched.append(part)

        if directive and unmatched:
            msg = "unknown directive: " + ", ".join(repr(s) for s in unmatched)
            raise DocumentError(msg)

        return cls(directive)

    @classmethod
    def from_comment(_, cls, s):
        "Create Directive instance from comment string, else return None"
        if isinstance(cls.re, str):
            pattern = [cls.re]
        elif cls.re is ALL:
            pattern = []
        else:
            pattern = cls.re

        a, kw = (), {}  # Argument tuple, keyword dictionary for new instance.

        for candidate in pattern:
            match = re.match(candidate, s)
            if match:
                a = match.groups()
                if hasattr(cls, "process_re_groups"):
                    a = cls.process_re_groups(a)
                break

        if cls.re is ALL:
            a = (s,)

        if not a:
            return None

        return cls(*a, **kw)


class Directive(Component):
    "Information for the machine running the build, not the human."


class FormatVersion(Directive):
    "Minimum major version of `buildme` required by input file."

    category = "meta"
    subcategory = PROG
    re = Document.Parser.V_RE + "$"  # Document.Parser scan cannot use `$`.

    def __init__(self, version):
        self.version = version

    @classmethod
    def process_re_groups(cls, groups):
        "Convert string version to integer."
        return (int(groups[0]),)  # Major version only.


class CommaDelimited:
    "Mixin to split content by comma."

    @classmethod
    def process_re_groups(cls, groups):
        "Parse list from comma-delimited text."
        assert len(groups) == 1
        return ([s.strip() for s in groups[0].split(",")],)


class FileEffect(Directive, CommaDelimited):
    "A file or directory created by, and owned by, the Section's build."

    category = "effect"
    re = r"creates?:\s*(.*)"

    def __init__(self, file):
        self.file = file


class Dependency(Directive, CommaDelimited):
    "Rebuild current Section if Section referenced as a Dependency changes."

    category = "dependency"
    re = r"requires?:\s*(.*)"

    def __init__(self, dependency):
        self.dependency = dependency


## Build Runner


class Runner:
    "Command-line entry point to run build for a Project."

    def __init__(self, output, debug=False):
        self.output = output
        self.debug = debug

    def clean(self, project):
        self.out(f"{PROG}: work in progress: clean")

    def err(self, *a, **kw):
        self.out(*a, **kw)

    def export(self, project):
        self.out(json.dumps(project.export(), indent=2))

    def outline(self, project):
        self.out(project.outline())

    def out(self, *a, **kw):
        self.output.out(*a, **kw)

    def run(self, project):
        self.out(f"{PROG}: work in progress: run")

    def __repr__(self):
        return f"{self.__class__.__name__}({self.output!r})"


## Build Output


class Output:
    "API for status information during build."

    prog = PROG

    def __init__(self, debug=False):
        self.debug = debug

    def out(self, message):
        "Output message with stdout semantics."
        raise NotImplementedError("subclass does not have `out` method")

    def err(self, message):
        "Output message with stderr semantics."
        raise NotImplementedError("subclass does not have `err` method")

    def exception(self, err):
        "Output summary of exception (critical error or program crash)."
        raise NotImplementedError("subclass does not have `exception` method")

    def __repr__(self):
        return f"{self.__class__.__name__}()"


class TerminalOutput(Output):
    "Output to terminal stdio."

    def out(self, message):
        "Print message to stdout."
        print(message)

    def err(self, message):
        "Print message to stderr."
        print(message, file=sys.stderr)

    def exception(self, err):
        """Print exception summary to stderr with input filename, line number.

        Importantly, output an exception summary for end-users, omitting the
        traceback and other detail that is irrelevant when attempting to run
        the program, not debug it.

        Prefix error message with filename and line number, if in context, in
        order to support conventional error output in which an IDE or $EDITOR
        can infer which line is the source of the error and provide a link.

        Example output to stderr:

            path/to/file:42: prog: error here on line 42

        In action:

            >>> err = DocumentError("example of an exception")
            >>> with contextlib.redirect_stderr(sys.stdout):
            ...     with context(filename="test", line_number=42):
            ...         TerminalOutput().exception(err)
            ...
            test:42: buildme: error: example of an exception
            >>>

        Without context:

            >>> err = DocumentError("example of an exception")
            >>> with contextlib.redirect_stderr(sys.stdout):
            ...     TerminalOutput().exception(err)
            ...
            buildme: error: example of an exception
            >>>
        """
        if self.debug:
            _, value, tb = sys.exc_info()
            traceback.print_exception(err, value, tb)

        message = ""
        if context.get("filename"):
            message += f"{context['filename']}:"
            if context.get("line_number"):
                message += f"{context['line_number']}:"
            message += " "

        message += f"{self.prog}: error: {err!s}"

        self.err(message)


## Global Context


class Context(collections.UserDict):
    """Manage global context, e.g. current file, line number.

    Set as context manager, passing one or more keyword arguments:

        with context(key=value):
            ...

    Get as dict:

        context[key]  #=> value
        context.get(key)  #=> value or None
        context.get(key, default)  #=> value or default

    Example:

        >>> context = Context()
        >>> with context(something="this"):
        ...     context["something"]
        ...
        'this'
        >>> context.get("something")
        >>> context.get("something", "default")
        'default'
        >>>

    Retain context upon exception, the primary reason for Context:

        >>> with context(something="this"):
        ...     assert False
        ...
        Traceback (most recent call last):
          ...
        AssertionError
        >>> context.get("something")  # Use this to report error in context.
        'this'
        >>>
    """

    @contextlib.contextmanager
    def __call__(self, **attributes):
        "Publish global attributes within a context manager."
        exception = False
        try:
            self.data.update(attributes)
            yield
        except Exception:
            exception = True
            raise
        finally:
            if not exception:
                for key in attributes:
                    self.data.pop(key, None)


context = Context()


## Error Definition


class DocumentError(RuntimeError):
    "Input document has invalid directives."


## Utility


def isiter(x):
    """True if object is iterable (implements iterator protocol), else False.

    Example:

        >>> isiter([])
        True
        >>> isiter(object())
        False
        >>>

    Checking does not exhaust generators:

        >>> gen = (x for x in range(10))
        >>> isiter(gen)
        True
        >>> isiter(gen)
        True
        >>> list(gen)
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        >>>
    """
    try:
        iter(x)
        return True
    except TypeError:
        return False


def match_arch(target, arch=None):
    """True if CPU arch string matches, defaulting to `uname -m`, else False.

    Support wildcards, e.g. "i*86" matches "i386", "i486", "i586", "i686":

        >>> match_arch("x86_64", arch="i686")
        False
        >>> match_arch("i*86", arch="i686")
        True
        >>>

    """
    if arch is None:
        arch = os.uname().machine
    if "*" in target:
        target = target.replace("*", ".*")  # Wildcard to regular expression.
    return bool(re.match(target + "$", arch, flags=re.IGNORECASE))


def memoize(fn, maxsize=None):
    "Decorator to cache function results."
    decorator = functools.lru_cache(maxsize=maxsize)
    return decorator(fn)


@contextlib.contextmanager
def open_file_or_stdin(filename, *a, **kw):
    "Wrap `open`, yielding sys.stdin if filename is '-' (ignoring keywords)."
    if filename == "-":
        yield sys.stdin
    else:
        with open(filename, *a, **kw) as file:
            yield file


def one_to_many(coll, key):
    "Index many-to-one collection into a one-to-many lookup."
    lookup = {}
    for value in coll:
        lookup[key(value)] = lookup.get(key(value), []) + [value]
    return lookup


@memoize
def subclass(cls):
    "Resolve subclass set of a given class, recursively."
    sub = lambda cls: cls.__subclasses__()
    return set(sub(cls)).union(s for c in sub(cls) for s in subclass(c))


## Self-Test


SAMPLE = f"""
# Document Title

## Section One

Required:

* `python3`
* `python3 -m this`
* `{__file__}`


## Section Two

### Subsection A

Run:

    python3 -c "print('Hello, world')"


### Subsection B

Run:

```
python3 -c "print('Hello, world')"
```


## Section Three

Nothing here.
""".lstrip()


def test_sample():
    """Test program against file containing SAMPLE text.

    Create sample markdown file:

        >>> import tempfile
        >>> file = tempfile.NamedTemporaryFile(mode="w", prefix="buildme-")
        >>> _ = file.write(SAMPLE)  # Returns number of bytes.
        >>> file.flush()

    Parse:

        >>> project = Project(file.name)
        >>> print(project.document[0].title)
        Document Title
        >>> print(project.document[0].section[0].name)
        Section One
        >>>

    Run:

        >>> runner = Runner(TerminalOutput())
        >>> runner.run(project)
        buildme: work in progress: run
        >>>

    Run full program at command line:

        >>> import subprocess
        >>> proc = subprocess.run(
        ...     [__file__, file.name],
        ...     stdout=subprocess.PIPE,
        ...     stderr=subprocess.STDOUT,
        ... )
        >>> print(proc.stdout.decode("ascii").strip())
        buildme: work in progress: run
        >>>

    Clean up:

        >>> file.close()
    """


FUTURE = """
# Document Title

Required:

* `python4`

<!-- buildme v9999 -->

Run:

```
date
```

<!-- creates: nothing; nonexistent-key: would fail if not for v9999 -->
""".lstrip()


def test_future():
    """Test program against file containing FUTURE text.

    Create sample markdown file:

        >>> import tempfile
        >>> file = tempfile.NamedTemporaryFile(mode="w", prefix="buildme-")
        >>> _ = file.write(FUTURE)  # Returns number of bytes.
        >>> file.flush()

    Parse:

        >>> project = Project(file.name)  # doctest: +ELLIPSIS
        Traceback (most recent call last):
            ...
        DocumentError: text requires v9999, but ...
        >>>
    """


def test():
    "Run self test."
    failure_count, test_count = doctest.testmod()
    if not failure_count:
        print(f"{PROG}: self-test: Ran {test_count} tests. All passed.")
    return failure_count


## Command Line

VERSION = (
    f"{PROG} {__version__}"
    + " "
    + "("
    + platform.python_implementation().replace("CPython", "Python")
    + " "
    + platform.python_version()
    + ")"
)


class ArgumentParser(argparse.ArgumentParser):
    "Parse command-line arguments."

    prog = PROG

    @classmethod
    def build(cls):
        "Build a configured argument parser instance."
        description, help = cls.parse_description_help()
        parser = cls(
            allow_abbrev=False,
            description=description,
            epilog=help,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            prog=cls.prog,
        )
        action = parser.add_mutually_exclusive_group(required=False)
        action.add_argument(
            "--export",
            action="store_true",
            help="export build steps (without running build)",
        )
        action.add_argument(
            "--outline",
            action="store_true",
            help="print outline of build steps (without running build)",
        )
        action.add_argument(
            "--clean",
            action="store_true",
            help="remove files output by build steps with known effects",
        )
        parser.add_argument(
            "--debug",
            action="store_true",
            help=f"include `{cls.prog}` debug output during build",
        )
        parser.add_argument(
            "--version",
            action="store_true",
            help=f"output version '{VERSION}' and exit",
        )
        parser.add_argument(
            "file",
            help="markdown file(s) containing literate build steps",
            nargs="+",
        )
        return parser

    @classmethod
    def parse_description_help(cls):
        "Parse command-line usage description and help from source code."
        with open(__file__) as file:
            description, help = "", ""
            for line in file:
                if line.startswith("#!"):
                    continue
                elif not line.startswith("#"):
                    break
                elif not description:
                    description = line[1:].strip()
                else:
                    help += "\n" + line[1:].strip()
            return description, help.strip()


class Main:
    "Dispatch based on command-line arguments."

    output_cls = TerminalOutput
    runner_cls = Runner

    def __init__(self):
        self.output = None
        self.runner = None

    def __call__(self, argv=sys.argv):
        if "--self-test" in argv:
            return test()

        if "--version" in argv:
            print(VERSION)
            return 0

        parser = ArgumentParser.build()
        arg = parser.parse_args(args=argv[1:])

        self.output = self.output_cls(debug=arg.debug)
        self.runner = self.runner_cls(self.output, debug=arg.debug)

        try:
            project = Project(*arg.file)

            if arg.clean:
                result = self.clean(project)
            elif arg.export:
                result = self.export(project)
            elif arg.outline:
                result = self.outline(project)
            else:
                result = self.run(project)
        except Exception as err:
            self.output.exception(err)
            result = 1

        return result

    def clean(self, project):
        "Execute `buildme --clean FILE...`."
        self.runner.clean(project)
        return 0

    def export(self, project):
        "Execute `buildme --export FILE...`."
        self.runner.export(project)
        return 0

    def outline(self, project):
        "Execute `buildme --outline FILE...`."
        self.runner.outline(project)
        return 0

    def run(self, project):
        "Execute `buildme FILE...`."
        self.runner.run(project)
        return 0

    def __repr__(self):
        return f"{self.__class__.__name__}()"


def lib():
    """Python is an implementation detail; if library absolutely necessary:

    Symlink (or copy) this Python file to add a .py extension.
    Python can readily import a .py file.

    Otherwise, use `importlib` to import this executable as a module.

    Reference the path to this program:

        >>> filepath = "path/to/buildme"  # Set this.
        >>> filepath = __file__  # Actual filepath for purpose of this test.

    Use Python import machinery:

        >>> from importlib.machinery import SourceFileLoader
        >>> from importlib.util import module_from_spec, spec_from_loader

        >>> loader = SourceFileLoader("buildme", filepath)
        >>> spec = spec_from_loader("buildme", loader)
        >>> buildme = module_from_spec(spec)
        >>> spec.loader.exec_module(buildme)

    The `buildme` object is now a module object just like any other:

        >>> buildme.Project
        <class 'buildme.Project'>
        >>> buildme.Runner
        <class 'buildme.Runner'>
        >>>

    The result is equivalent to that of `import buildme`.
    """


main = Main()


if __name__ == "__main__":
    sys.exit(main())
